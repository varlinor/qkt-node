import fs from 'fs-extra'
import path from 'path'
import { camelCase, upperFirst } from 'lodash-es'
import { selectSfc, normalizePath } from '@varlinor/node-tools'
import { SfcDefineInfo } from '../types'


/**
 * 基于包的根目录生成组件定义文件，针对ts编写的vue3的sfc
 * @param packageRoot
 * @param isTs
 * @param isOutputEntry 是否输出入口文件
 * @param prefix 组件名前缀
 * @param mode 合并模式
 */
export async function generateSfcDefineAndEntryFiles(
  packageRoot: string,
  isTs: boolean = false,
  isOutputEntry: boolean = true,
  prefix: string = 'Qkt',
  mode: string = 'merge'
) {
  if (!packageRoot) {
    packageRoot = process.cwd()
  }
  console.log('current package root dir:', packageRoot)
  // 检查components.json
  const defPath = path.join(packageRoot, 'components.json')
  let preComDefs:SfcDefineInfo[] = []
  if (fs.existsSync(defPath)) {
    const comDefsInfo = fs.readFileSync(defPath, 'utf-8')
    if (comDefsInfo) {
      try {
        preComDefs = JSON.parse(comDefsInfo)
      } catch (error) {
        console.error('Error parsing components.json:', error)
      }
    }
  }
  const selected = await selectSfc(packageRoot, isTs)
  const srcScriptSuffix = isTs ? '.ts' : '.js'
  const allSelectedInfo=[]
  let comDefs:SfcDefineInfo[] = []
  const newDefs:SfcDefineInfo[] = []
  const entryGenArr:SfcDefineInfo[] = []  // 待生成入口文件的列表
  if (Array.isArray(selected)) {
    const packageName = path.basename(packageRoot)
    console.log('packageName:', packageName)
    for (const file of selected) {
      // 考虑将非vue的文件跳过。
      // console.log('per file:', file)
      const name = file.endsWith(srcScriptSuffix) ? path.basename(file, srcScriptSuffix) : path.basename(file, '.vue')
      const filename = path.basename(file) // 文件名
      const parentPath = path.dirname(file)  // 文件父路径
      const parentDirName = path.basename(parentPath)  // 父路径文件夹名
      const relatedParentPath = normalizePath(parentPath).replace(normalizePath(packageRoot), '')
      // packages开头
      const basedir = `packages/${packageName}${relatedParentPath}`
/*       allSelectedInfo.push({
        name,
        parentPath,
        parentDirName,
        file
      }) */
      let info:SfcDefineInfo = {
        packageName,
        basedir,
        filename,
        importPath: `./${filename}`,
        outputPath: relatedParentPath,
      }
      // 判断文件名，注意：这里的 outputFileName 用于打包输出的文件名，因此入口文件生成时，单独根据index来判定
      if ('index.vue' === filename) {
        // 本身就是可以作为入口文件，打包成index.js，因本身是
        info.exportName = `${prefix}${upperFirst(camelCase(parentDirName))}`
        info.outputFileName = `index`
      }else if ('main.vue' === filename) {
        // 需要生成index.js
        info.exportName= `${prefix}${upperFirst(camelCase(parentDirName))}`
        info.outputFileName= `index`
        entryGenArr.push(info)
      }else{
        // 如果父路径下存在多个打包文件，则生成index-文件名.js
        info.exportName = `${prefix}${upperFirst(camelCase(name))}`
        info.outputFileName = name
        entryGenArr.push(info)
      }
      newDefs.push(info)
    }

    if(isOutputEntry && !!entryGenArr.length){
        // 生成入口文件
      entryGenArr.forEach((item)=>{
        const entryFileName = item.outputFileName ==='index' ? 'index' : `index-${item.outputFileName}`
        const entryFilePath = path.join(packageRoot, item.outputPath, `${entryFileName}${srcScriptSuffix}`)
        if (!fs.existsSync(entryFilePath)) {
          // 生成entry文件
          const entryContent = formatEntryContent({
            exportName: item.exportName,
            relatePath: item.importPath
          })
          fs.writeFileSync(entryFilePath, entryContent)
          console.log('generate entry file:' + entryFilePath)
        }
      })
    }

    comDefs = formatComponentDefines(mode, preComDefs, newDefs,{
      packageRoot, suffix:srcScriptSuffix,
    })

    if (comDefs.length) {
      fs.writeFileSync(defPath, JSON.stringify(comDefs, null, 2))
      console.log(`Components Define file [${defPath}] is generated!`)
    } else {
      console.log('No file need to be output!')
    }
  }

  return { defineInfos: comDefs, selectedFiles: selected }
}

/**
 * 格式化单个组件的install内容
 * @param {*} comInfo {exportName,relatePath}
 * @returns
 */
export function formatEntryContent(comInfo: {exportName: string, relatePath: string}) {

  return `
/* Automatically generated by '@varlinor/cli' */

import ${comInfo.exportName} from '${comInfo.relatePath}'

${comInfo.exportName}.install = function (Vue) {
  Vue.component('${comInfo.exportName}', ${comInfo.exportName})
}

export default ${comInfo.exportName}
`.trim()
}

/**
 * 校验组件定义
 * @param {*} mode 合并模式
 * @param {*} preComDefs 之前的定义
 * @param {*} compDefines 最新的定义
 * @returns
 */
function formatComponentDefines(mode:string = 'merge',
  preComDefs:SfcDefineInfo[], compDefines: SfcDefineInfo[],
  opts={packageRoot:string = '', suffix:string = ''}):SfcDefineInfo[] {
  if(mode ==='merge'){
    const newComDefs:SfcDefineInfo[]=[]
    const { packageRoot, suffix } = opts
    for (const preInf of preComDefs) {
      const {packageName,basedir,filename, outputPath, outputFileName} =preInf

      // 存在相同的定义
      const cur = compDefines.find((p)=>{
        return p.packageName ===packageName &&
          p.basedir === basedir &&
          p.filename === filename &&
          p.outputPath === outputPath &&
          p.outputFileName === outputFileName
      })
      // 只在pre中存在
      if(!cur){
        const entryFileName = outputFileName ==='index' ? 'index' : `index-${outputFileName}`
        const entryFile = path.join(packageRoot, outputPath, `${entryFileName}${suffix}`)
        // 检查pre中的入口文件是否存在
        if(fs.existsSync(entryFile) || filename ==='index.vue'){
          newComDefs.push(preInf)
        }else{
          console.log('%s is not exist, remove it\'s defineInfo',entryFile)
        }
      }
    }
    newComDefs.push(...compDefines)
    return newComDefs
  }else if(mode === 'replace'){
    return compDefines
  }else{
    return [] as SfcDefineInfo[]

  }
}
